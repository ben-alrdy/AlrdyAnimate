{"version":3,"file":"AlrdyAnimate.js","mappings":"mBAIAA,SAASC,iBAAiB,oBAAoB,KAC5C,MAAMC,EAAWC,OAAOC,WAAa,IACTJ,SAASK,iBAAiB,gBAElCC,SAASC,IAC3B,MAAMC,EAAWD,EAAQE,aAAa,aAChCC,EAAWH,EAAQE,aAAa,eAChCE,EAAQJ,EAAQE,aAAa,YAC7BG,EAAiBL,EAAQE,aAAa,aAC5C,IAAII,EAAgBN,EAEhBG,GACFH,EAAQO,MAAMC,YAAY,uBAAwBL,GAGhDR,GAAyB,aAAbM,EACdD,EAAQO,MAAMC,YAAY,oBAAqB,MACtCJ,GACTJ,EAAQO,MAAMC,YAAY,oBAAqBJ,GAG7CC,IACFC,EAAgBb,SAASgB,cAAcJ,IAGzC,MAAMK,EAAyBV,EAAQE,aAAa,eACpD,IAAIS,EAAqBD,EACrBE,WAAWF,GACX,GAEJ,IACGG,MAAMF,IACPA,GAAsB,GACtBA,GAAsB,EACtB,CAEA,MAIMG,EAAc,IAAIC,sBACrBC,IACCA,EAAQjB,SAASkB,IACXA,EAAMC,gBACRlB,EAAQmB,UAAUC,IAAI,UACxB,GACA,GAEJ,CACEC,UAAW,CAAC,EAAG,GACfC,WAboB,YADwB,KAA1B,EAAIX,YAmBpBY,EAAiB,IAAIR,sBACxBC,IACCA,EAAQjB,SAASkB,IACf,MAAMO,EAAOP,EAAMQ,OAAOC,yBACrBT,EAAMC,gBAAkBM,EAAKG,KAAO/B,OAAOgC,aAC9C5B,EAAQmB,UAAUU,OAAO,UAC3B,GACA,GAEJ,CACER,UAAW,EACXC,WAAY,QAIhBR,EAAYgB,QAAQxB,GACpBiB,EAAeO,QAAQxB,EACzB,IACA,G","sources":["webpack://alrdy-animations/./src/js/AlrdyAnimate.js"],"sourcesContent":["import styles from \"../scss/AlrdyAnimate.scss\";\n\n// import throttle from './utils/throttle';\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const isMobile = window.innerWidth < 768;\n  const allAnimatedElements = document.querySelectorAll(\"[aa-animate]\");\n\n  allAnimatedElements.forEach((element) => {\n    const aaMobile = element.getAttribute(\"aa-mobile\");\n    const duration = element.getAttribute(\"aa-duration\");\n    const delay = element.getAttribute(\"aa-delay\");\n    const anchorSelector = element.getAttribute(\"aa-anchor\");\n    let anchorElement = element;\n\n    if (duration) {\n      element.style.setProperty(\"--animation-duration\", duration);\n    }\n\n    if (isMobile && aaMobile === \"no-delay\") {\n      element.style.setProperty(\"--animation-delay\", \"0s\");\n    } else if (delay) {\n      element.style.setProperty(\"--animation-delay\", delay);\n    }\n\n    if (anchorSelector) {\n      anchorElement = document.querySelector(anchorSelector);\n    }\n\n    const viewportPercentageAttr = element.getAttribute(\"aa-viewport\");\n    let viewportPercentage = viewportPercentageAttr\n      ? parseFloat(viewportPercentageAttr)\n      : 0.8;\n\n    if (\n      !isNaN(viewportPercentage) &&\n      viewportPercentage >= 0 &&\n      viewportPercentage <= 1\n    ) {\n      // Calculate rootMargin based on the viewport percentage for the primary observer\n      const bottomMargin = (1 - viewportPercentage) * 100;\n      const rootMarginValue = `0px 0px -${bottomMargin}% 0px`;\n\n      // Primary observer to add 'in-view' class\n      const addObserver = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            if (entry.isIntersecting) {\n              element.classList.add(\"in-view\");\n            }\n          });\n        },\n        {\n          threshold: [0, 1], // Trigger callback when any part or the whole element is visible\n          rootMargin: rootMarginValue,\n        }\n      );\n\n      // Secondary observer to remove 'in-view' class when moving out of the viewport from the bottom\n      const removeObserver = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            const rect = entry.target.getBoundingClientRect();\n            if (!entry.isIntersecting && rect.top >= window.innerHeight) {\n              element.classList.remove(\"in-view\");\n            }\n          });\n        },\n        {\n          threshold: 0, // Trigger callback when the element is not visible at all\n          rootMargin: \"0px\", // Ensure this observer uses the full viewport\n        }\n      );\n\n      addObserver.observe(anchorElement);\n      removeObserver.observe(anchorElement);\n    }\n  });\n});\n"],"names":["document","addEventListener","isMobile","window","innerWidth","querySelectorAll","forEach","element","aaMobile","getAttribute","duration","delay","anchorSelector","anchorElement","style","setProperty","querySelector","viewportPercentageAttr","viewportPercentage","parseFloat","isNaN","addObserver","IntersectionObserver","entries","entry","isIntersecting","classList","add","threshold","rootMargin","removeObserver","rect","target","getBoundingClientRect","top","innerHeight","remove","observe"],"sourceRoot":""}